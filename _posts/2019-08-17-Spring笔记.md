---
date: 2019-08-17 11:11
status: public
layout: post
title: 2019-08-17 Spring笔记
---

# Bean装配
## 自动装配
### component scanning
```java
@Configuration
@ComponentScan(basePackage="")
@ComponentScan(basePackage={XX.class,XXX.class})
@Component([beanName])
```
### autowiring
@Autowired(required=false)

### javax注解代替spring注解
@Name代替@Component
@Inject代替@Autowired

## JAVA装配
@Configuration
@Bean(name="")+方法return
> Spring默认单例，建议将装配参数放在函数参数里

```java
@Bean
public CDPlayer cdPlayer(Disc disc){return new CDPlayaer(disc);}
```
## XML装配
除非必要，否则尽可能不用XML

## 装配混合
```java
@Configuration
@Import({AConfig.class,BConfig.class})
@ImportResource("classpath:xxx-config.xml")
```
```xml
<bean class="com.example.AConfig"/>
<import/>
```
## Profile
@Profile("dev")
```xml
<beans ... profile="dev">...</beans>
```
@ActiveProfiles
在web.xml中设置
```xml
<para-name>spring.profiles.default</para-name>
<para-value>dev</para-value>
```
这样所有从依赖上下载代码的开发都可以直接在嵌入式环境中运行了
运维再去设置spring.profiles.active即可，这时系统优先active
## 其他
@Conditional([为true才创建]) Profile其实就用了这个注解
@Primary 自动装配时首选 @Component @Bean都可用
@Qualifier("cold") 限定符 
也可以自定义限定符注解，更加类型安全
@Rentention(RUNTIME)
@Qualifier
public @interface @Cold
## Bean作用域
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
单例：Singleton 默认
当类可变时，单例就不合适了
原型：Prototype 每次都创建新的实例
会话：Session Web中每个会话创建新的实例 购物车啊
请求：Request Web中为每个请求创建新的实例
## 运行时注入
```java
@PropertySource注解和Environment
@Configuration
@PropertySource("classpath:/com/soundsystem/app.properties")
public class EnvironmentConfig {

  @Autowired
  Environment env;
  
  @Bean
  public BlankDisc blankDisc() {
    return new BlankDisc(
        env.getProperty("disc.title"),
        env.getProperty("disc.artist"));
  }
  
}
```
## SpEL
可以做到很强大的运行时注入，而且很清晰
  #{...}
  
# AOP
Spring4种AOP
1. 经典代理
2. POJO切面
3. @AspectJ注解驱动切面
4. 注入式AspectJ切面 （更强但不介绍了）
注意 Spring AOP仅支持方法层面的AspectJ语法
## 注解 简单方便
@Aspect
public class A{
@Pointcut("execution(** com.ep.run(..))")
public void runAMehtod()
@Before("runAMehtod()")
public void somethien(){...}
@After @AfterReturning @AfterThrowing
@Around

注意，光建立Bean不够，还需要转成切面
@EnableAspectJAutoProxy自动代理
```xml
<aop:aspectj-autoproxy>
```
### 环绕方法
```java
@Around(...)
public void something(ProceedingJoinPoint jp){
    jp.procced();
}
```
你可以不执行jp.procced()，实现鉴权逻辑
你甚至可以执行多次jp.procced()，实现重试逻辑

### 注解给类动态添加方法
@DeclareParents 比较骚的操作


# WebMVC
## servlet
servlet3 and Spring3.1后 无需配置web.xml
extends AbstractAnnotationConfigDispatcherServletInitializer
然后重载方法中指定配置类即可

在配置类中加
@EnableWebMvc
extends WebMvcConfigurerAdapter 
## mapping
这个会了
## 处理请求
1. 查询参数（Query Parameter）。
2. 表单参数（Form Parameter）。 
3. 路径变量（Path Variable）。


```java
/spittles/show?max=12345&count=50
List<Result> list(
@RequestPara(value="max",defalut=...) long max,
@RequestPara(value="count",defalut="20") int count{...}

GET /spittles/show/12345
@GetMapping("/show/{id}")...(
@PathVariable("id") long id,Model model)...{
//可以用model.addAttribute()将结果传给view，但用json就没必要了
}
```

### 表单校验
在pojo字段加上注解比如@NotNULL @Size(min=5,max=15)
在RequestMapping时参数加上@Valid 和 Errors errors
errors.hasErrors()则返回前端错误

## 进阶
### servlet扩展
implents WebApplicationInitializer来注册Servlet，增加filter
### multipart请求
比如表单中包含上传图片
用上述扩展方式创建DispathcerServlet后
调用其setMultipartConfig()方法，传入个MultipartConfigElement实例，你也可以重载它做更细节的设置

之后，定义MultipartResolver的Bean
标准StandardServletMultipartResolver
也可以CommonsMultipartResolver

接受时@RequestPart("pic") byte[] pic
推荐用MultipartFile 或 Part代替byte[]
### 异常处理
#### 处理异常
@ExceptionHandler(异常类.class)
#### 捕获异常
@ControllerAdvice处理所有控制器的异常，会比较方便
#### 异常与状态码
默认时，Spring会将一些异常转换成合适的错误码
@ResponseStatus 也可以将异常转为错误码
异常|状态码
-|-
BindException |400 - Bad Request
ConversionNotSupportedException |500 - Internal Server Error
HttpMediaTypeNotAcceptableException |406 - Not Acceptable
HttpMediaTypeNotSupportedException |415 - Unsupported Media Type
HttpMessageNotReadableException |400 - Bad Request
HttpMessageNotWritableException |500 - Internal Server Error
HttpRequestMethodNotSupportedException |405 - Method Not Allowed
MethodArgumentNotValidException |400 - Bad Request
MissingServletRequestParameterException |400 - Bad Request
MissingServletRequestPartException |400 - Bad Request
NoSuchRequestHandlingMethodException |404 - Not Found
TypeMismatchException |400 - Bad Request

### 重定向
当控制器方法返回的String值 以“redirect:”开头的话，那么这个String不是用来查找视图的， 而是用来指导浏览器进行重定向的路径。
不推荐字符串链接
推荐用占位符，不安全字符串都会被转义
```java
model.addAttribute("username",user.getName());
return "/redirect:/spitter/{username}";
```

## RestFul
注解或类|说明
-|-
@RequestBody| 获取Json
@ResponseBody| 返回Json
@RestController| 默认每个方法都是@RequestBody
@ResponseStatus| 
ResponseEntity<T>| 封装返回值和状态码 

# WebFlow
一种Web框架，适用于元素按规定流程运行的程序

# Web Security
Filter层处理Url
Aop层处理鉴权

## 11个安全模块
> ACL Aspects CAS客户端 Configuration Core Cryptography LDAP OpenID Remoting 标签库（Tag Library） Web 

Core和Configuration 是至少的
Web应用再引入Web模块
与jsp的标签库（Tag Library）

## filter过滤Web请求
在web.xml引入DelegatingFilterProxy的filter
当然也可以用Java引入的方式

## 安全性配置Config类
@EnableWebSecurity
@EnableMvcSecurity //用MVC的话用这个代替上面那个
extends WebSecurityConfigurerAdapter

要做的事：
1. 配置用户存储 (内存，datasource或者LDAP) 用AuthenticationManagerBuilder
2. 指定哪些请求需要认证以及权限 用HttpSecurity
3. 提供JSP安全的登录页面

重载三个configure方法
WebSecurity | 配置filter链 
HttpSecurity | 拦截url与设定权限 应对上事项2
AuthenticationManagerBuilder| 配置user-detail 应对上事项1



## 鉴权
HttpSecurity authenticated().antMatchers()等一系列方法

SpEL可以实现更复杂的鉴权，比如只允许某用户周二登录

requiresChannel()方法会为选定的URL强制使用HTTPS 敏感数据很重要

注意，Spring Security 3.2开始，默认就会启用CSRF防护，他通过匹配token来确保正常，这意味着在你的应用中，所有的表单必须在一个“_csrf”域中提交 token。 调用csrf().disable()可禁用它

## 登录
表单登录 注意加_csrf属性即可 .formLogin().loginPage()

HttpBasic登录 用于非web应用 就是那种弹窗登录 .httpBasic().realmName("作用域")

保留登录状态 rememberMe().tokenValiditySeconds("时间") 通过"remember-me"的属性可以实现选择是否记住登录

退出登录 退出功能是通过Servlet容器中的Filter实现的（默认情况下），这个 Filter会拦截针对“/logout”的请求 因此href=@{/logout}即可
可以用logout().logoutSuccessUrl("/")配置重定向路径

## 保护视图
登录成功后应该予以反馈，Json实现的话就前端去做吧

# 数据库
## 接口 异常 与模板
用接口隔离数据库dao实现，方便测试

SQLException异常提供的信息有限，Spring提供了更丰富的异常，而且是非受检异常，可以不用写catch块

模板  省略大量重复细节（包括资源获取和关闭，事务提交与回滚）， 而将具体应用与数据以callback的形式暴露给使用者

## 配置数据源
1. JNDI配置外部数据
2. 使用数据源连接池
3. JDBC驱动的数据源 dbcp c3p0 druid
DriverManagerDataSource 和 SimpleDriverDataSource，虽然配置简单，但是性能不如连接池
4. Spring简化的H2嵌入式数据源

别忘了用@Profile来区分数据源

## JDBC模板

class|说明
-|-
JdbcTemplate|最基本的Spring JDBC模板，这个模板支持简 单的JDBC数据库访问功能以及基于索引参数的查询；
NamedParameterJdbcTemplate|使用该模板类执行查询时 可以将值以命名参数的形式绑定到SQL中，而不是使用简单的索引参数； 
~~SimpleJdbcTemplate~~已废弃|该模板类利用Java 5的一些特性如自动装箱、泛型以及可变参数列表来简化JDBC模板的使用。 

JdbcTemplate 在update时 可以用命名参数的Map<String, Object>，这样会更加不容易出错。

## ORM
更方便，而且提供
1. 延迟加载
2. 预先抓取
3. 级联 当删除Order对象时，同时在数据库中删除关联的LineItem

### Hibernate 
使用Hibernate所需的主要接口 是org.hibernate.Session。Session接口提供了基本的数据访 问功能，如保存、更新、删除以及从数据库加载对象的功能

用LocalSessionFactoryBean创建一个Session的Bean实例
然后设置它的Mapping.xml和Dialect

如果你更倾向于使用注解的方式来定义持久化，并且你还没有使用 Hibernate 4的话，那么需要使用AnnotationSessionFactoryBean来代替 LocalSessionFactoryBean

然后在Dao类上用@Repository注解，这个注解一来创造Bean，二来提供异常转换
使用异常转换要结合 PersistenceExceptionTranslationPostProcessor 这个Bean去做，它会把@Repository注解的Bean加一个Advisor

### Hibernate with JPA
~~暂时没看到能用的maven依赖，
每次都是单独用没问题，和MVC一起光是添加pom就会报错“NoSuchMethodError”
因此暂时放弃~~
可以用了，之前是pom配置出了问题。。
版本如果不符会出很多麻烦的问题

JPA有2个实体管理工厂

1. LocalEntityManagerFactoryBean
2. LocalContainerEntityManagerFactoryBean
   
一般用第二个可以减少更多配置xml，全靠javaConfig与注解完成。
Local|LocalCOntaner
-|-
需要persistence.xml| 用setDataSource setJpaVendorAdapter
需要mappping.xml| 用@Entity 和 setPackagesToScan

config类加上
@EnableJpaRepositories
就能自动检索@Repository注解的类，以及Jpa自动实现的接口。自动接口十分方便

Pom
```xml
<dependency><!-- 提供Entity注解 -->
  <groupId>javax.persistence</groupId>
  <artifactId>javax.persistence-api</artifactId>
  <version>2.2</version>
</dependency>
<dependency><!-- jpa -->
  <groupId>org.springframework.data</groupId>
  <artifactId>spring-data-jpa</artifactId>
  <version>2.1.10.RELEASE</version>
</dependency>
<dependency><!-- jpa实现 -->
  <groupId>org.hibernate</groupId>
  <artifactId>hibernate-core</artifactId>
  <version>5.4.4.Final</version>
</dependency>
```

datasource 我是定义在xml里的，为了方便区分Test，所以这里没有定义

```java
@Configuration
@EnableJpaRepositories(basePackageClasses = com.qunar.fresher.springmvc.dao.BookRepository.class)
@EnableTransactionManagement
public class JpaConfig {

    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory(
            DataSource dataSource,
            JpaVendorAdapter jpaVendorAdapter
    ){
        LocalContainerEntityManagerFactoryBean emfb = new LocalContainerEntityManagerFactoryBean();
        emfb.setPackagesToScan("com.qunar.fresher.springmvc.model");
        emfb.setDataSource(dataSource);
        emfb.setJpaVendorAdapter(jpaVendorAdapter);
        return emfb;
    }

    @Bean
    public JpaVendorAdapter jpaVendorAdapter(){
        HibernateJpaVendorAdapter adapter=new HibernateJpaVendorAdapter();
        adapter.setGenerateDdl(true);
        adapter.setShowSql(true);
        adapter.setDatabasePlatform("org.hibernate.dialect.MySQL8Dialect");
        adapter.setDatabase(Database.MYSQL);
        return adapter;
    }

    @Bean
    public JpaTransactionManager transactionManager(EntityManagerFactory emfb){
        JpaTransactionManager jpaTransactionManager = new JpaTransactionManager();
        jpaTransactionManager.setEntityManagerFactory(emfb);
        return jpaTransactionManager;
    }

}

//这个接口会被自动实现
@Transactional
public interface BookRepository  extends JpaRepository<Book,Long> {
}

//然后就能直接用了
@Test
public void bean(){
    ApplicationContext context = new ClassPathXmlApplicationContext("mvc.xml");
    BookRepository dao = context.getBean(BookRepository.class);
    assertNotNull(dao);
}

```
